<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>hz初学Vue.js</title>
  <script src=vue.js></script>
  <script src="http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js"></script>
  <script src="https://unpkg.com/vue/dist/vue.js"></script>
  <script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
  </script>

  <style type="text/css">
    #panel,
    #flip {
      padding: 5px;
      text-align: center;
      background-color: #e5eecc;
      border: solid 1px #c3c3c3;
    }

    #panel {
      padding: 50px;
      display: none;
    }
  </style>


</head>

<body>
  <!--锚-->
  <!--锚
  <div id="mao">
    <a v-for="(item,index) in brlist" v-bind:href="char+index">{{char}}{{index}}:{{item.title}}</a>
    </br>
  </div>
  -->
  <div id="mao">
    <fmao v-for="(n,index) in brlist" v-bind:fuhao=fuhao v-bind:anchor=fuhao+char+index v-bind:title=n v-if="index!=0" key=index></fmao>
  </div>

  <a style="color:blue;font-size:30px;" name="chapter0">0 引言</a>
  <p>TODO：锚的#怎么打?</p>
  <!--
  <div id="mao2">
    <maos v-for="item in brlist" v-bind:mao="item" v-bind:char="char"  ></maos>
  </div>
  -->
  <!--锚 end -->
  <p>例1</p>
  <p>锚就是vue组件实现的:</p>

  <pre style="border:1px solid #999;">
 &ltdiv id="mao"&gt
    &ltfmao v-for="(n,index) in brlist" v-bind:fuhao=fuhao v-bind:anchor=fuhao+char+index v-bind:title=n v-if="index!=0" key=index&gt&lt/fmao&gt
  &lt/div&gt

Vue.component('fmao', {
    props: ['anchor', 'title','fuhao'],
    template: '&ltdiv >\
    &lta  v-bind:href=anchor>{{anchor}}:{{title}}&lt/a&gt\
     &lt/br>\
     &lt/div>'
})

var br = new Vue({
    el: "#mao",
    data: {
        fuhao:'#',
        char: 'chapter',
        brlist: ['学习vue', 'vue基础','vue组件']
    },

})
</pre>

  </br>

  <p>例2</p>
  <div id="pre2" style="border:1px solid #999;">
    <pre2 v-for="(item,index) in pre2list" v-bind:mao="item" key=index></pre2>
  </div>

  <p>v-bind:实现属性和数据的绑定</p>
  <p>v-bind：可以缩写成 ：</p>
  <p>下面的title属性被绑定成数据message=hello vue</p>
  <p id="haha" v-bind:title="message">nihao</p>


  <!--第一章-->

  <a style="color:blue;font-size:30px;" name="chapter1">1 vue基础</a>
  <p style="color:red;font-size:15px;">1 vue实例</p>
  <p> new Vue()，这叫<strong style="color:coral">构造器</strong></p>


  <div style="border:1px solid #999;">
    <p id="p1" v-bind:title="a">nihao2</p>
    <p>这些被代理的属性是响应的，也就是说值的任何改变都是触发视图的重新渲染。</p>
    <button id="btn11" onclick="changenihao2()">change nihao2</button>
    </br>
  </div>

  <!--答案-->
  <p>$的作用，抽出属性</p>
  <div id="ans11" style="border:1px solid #999;">
    <p v-for="item in ans11list" v-if="seen">{{item}}
      <p>
  </div>
  </br>
  <input id="btn111" type="button" value="隐藏" onclick="hideans()">
  </br>


  <pre>
  每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如，实例需要配置数据观测(data observer)、编译模版、挂载实
  例到 DOM ，然后在数据变化时更新 DOM 。在这个过程中，实例也会调用一些 生命周期钩子 ，这就给我们提供了执行自定义逻辑的机会。
  例如，created 这个钩子在实例被创建之后被调用.
  
 <!-- <img src="https://cn.vuejs.org/images/lifecycle.png"  ></img>-->
 <a href="https://cn.vuejs.org/images/lifecycle.png" target="blank" >生命周期 <a>
    </pre>


  <p style="color:red;font-size:15px;">2 vue模板</p>
  <pre>
通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上所有的数据绑定
  </pre>

  <div style="border:1px solid #999;">
    <p id="p121" v-once v-bind:title="a">nihao v-once,数据：{{a}}</p>
    <button id="btn12" onclick="changenihaovonce()">change nihao v-once</button>
    </br>
  </div>

  <div style="border:1px solid #999;">
    <p id="p122" v-if="seen"> Vue.js 提供了完全的 JavaScript 表达式支持。{{ ok ? 'YES' : 'NO' }} </p>

    <input id="btn13" type="button" value="模板支持js表达式 NO" onclick="changeok()">
    <input id="btn14" type="button" value="v-if的用法： 隐藏" onclick="changevif()">
  </div>

  <p style="color:green;">过滤器TODO</p>

  <p style="color:red;font-size:15px;">3 vue计算属性computed (注意官方文档对其与methods,watch区别的说明)</p>
  <div style="border:1px solid #999;">
    <div id="comp1">
      <p>Original message: "{{ message }}"</p>
      <p>Computed reversed message: "{{ reversedMessage }}"</p>
    </div>
  </div>

  <a href="https://cn.vuejs.org/v2/guide/computed.html" target="blank">官文watch method的对比</a>
  <pre>
  与官文methods不同的是,计算属性是基于message和reversedMessage的依赖进行缓存的
  只要 message 还没有发生改变，多次访问 reversedMessage 计算属性computed会立即返回之前的计算结果，而不必再次执行函数。
  相比而言，只要发生重新渲染，method 调用总会执行该函数。
  官文上，与的watch相比，compute 有事更简洁
  </pre>

  <p>computed 的getter和setter</p>
  <p>firstname lastname 和fullName产生了联系</p>

  <div style="border:1px solid #999;">
    <div id="v1name">
      <p><b style="color:aqua">fullName:</b>{{fullName}} </p>
      <p><b style="color:aqua">firstname:</b>{{firstName}} </p>
      <p><b style="color:aqua">lastName:</b> {{lastName}}</p>

      firstname <input id="v1firstname" name="firstname"></br>
      lastname <input id="v1lastname" name="lastname"></br>

      <button v-on:click="v1setname">submit</button>

    </div>
    <pre>
      Vue 提供一个更通用的方法通过 watch 选项，来响应数据的变化。当你想要在数据变化响应时，执行异步操作或开销较大的操作，这是很有用的。例子见官网yesno。
    </pre>
  </div>


  <p style="color:red;font-size:15px;">4 vue class style 略</p>
  <p style="color:red;font-size:15px;">5 vue 条件渲染v-if v-show</p>

  <a href="http://www.cnblogs.com/wmhuang/p/5420344.html" target="blank">v-if 和v-show的区别</a>
  <pre>
手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；
使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换。
用template可以v-if整个组
2.1版本新增了 v-else-if可满足条件控制的需求
</pre>

  <div style="border:1px solid #999;" id="v1login">
    <p>{{indexlogin}}{{logintype}}</p>

    <template v-if="logintype=='user'">
      <label>用户名登陆</label>
      <input placeholder="Enter you name">
    </template>

    <template v-if="logintype=='QQemail'">
      <label>QQ邮箱登陆</label>
      <input placeholder="Enter your QQemail">
    </template>

    <template v-if="logintype=='sinaemail'">
      <label>sina邮箱登陆</label>
      <input placeholder="Enter your sinaemail">
    </template>
    </br>

    <p style="color:coral">试验时写错的地方 1.&lt/template&gt &lt/template&gt 2.logintype='sinaemail' </p>


    <button v-on:click="changelogintype">toggle login type</button>

    <p>那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模版使用了相同的元素，&ltinput&gt 不会被替换掉——仅仅是替换了它的 placeholder。</p>
    <p>这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来声明“这两个元素是完全独立的——不要复用它们”。只需添加一个具有唯一值的 key 属性即可：</p>
    <p> &ltinput placeholder="Enter you phone" <a style="color:red">key="phone"&gt</a></p>

    <p>联系方式</p>
    <template v-if="connect=='phone'">
      <label>电话号码</label>
      <input placeholder="Enter you phone" key="phone">
    </template>

    <template v-if="connect=='email'">
      <label>邮箱</label>
      <input placeholder="Enter you email" key="email">
    </template>
    <button v-on:click="changeconnect">toggle connect type</button>
  </div>


  <p style="color:red;font-size:15px;">6 vue 列表渲染v-for</p>
  <p>看标题锚的例子：</p>
  <p>(item,index) in brlist的index是个索引</p>
  <div style="border:1px solid #999;" id="v1login">
    <p>&lta&gtv-for="(item,index) in brlist" v-bind:href="char+index">{{char}}{{index}}:{{item.title}}&lt/a&gt</p>
  </div>

  <p>如同 v-if 模板，你也可以用带有 v-for 的 &lttemplate&gt 标签来渲染多个元素块。</p>
  <p>整数迭代：&ltspan&gt v-for="n in 10">{{n}} &lt/span&gt(失败了。。。)</p>
  <div>
    <span v-for="n in 10">{{ n }} </span>
  </div>

  <p>你也可以用 v-for 通过一个对象的属性来迭代。</p>

  <p style="color:red;font-size:15px;">7 vue 事件v-on（可缩写v-on:click ---> @click）</p>

  <p>v-on基础，见上面按钮的实现</p>
  <p>内联处理器 </p>
  <p>有时也需要在内联语句处理器中访问原生 DOM 事件。可以用特殊变量 $event 把它传入方法：</p>
  <div style="border:1px solid #999;" id="v1neilian">
    <p>&ltbutton v-on:click="say('hi')"&gtSay hi&lt/button&gt </p>
    <p>&ltbutton v-on:click="warn('Form cannot be submitted yet.', $event)"&gtSubmit&lt/button&gt</p>
    <button v-on:click="say('hi')">Say hi</button>
    <button v-on:click="warn('Form cannot be submitted yet.', $event)">Submit</button>
  </div>
  <a href="https://cn.vuejs.org/v2/guide/events.html" target="blank">事件修饰符,键盘鼠标事件修饰符,官网,重要</a></br>

  <p style="color:red;font-size:15px;">8 vue 表单渲染v-model</p>
  <pre>
  你可以用 v-model 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。
  尽管有些神奇，但 v-model 本质上不过是语法糖，它负责监听用户的输入事件以更新数据，并特别处理一些极端的例子。
<div style="background:#D3D3D3;">
  &ltinput v-model="something"&gt  
</div>
  相当于：
<div style="background:#D3D3D3;">
  &ltinput
  v-bind:value="something"
  v-on:input="something = $event.target.value"&gt
</div>
  默认情况下，一个组件的 v-model 会使用 value 属性和 input 事件，但是诸如单选框、复选框之类的输入类型可能把 value 属性用作了别的目的。
  model 选项可以回避这样的冲突：
  <div style="background:#D3D3D3;">
  Vue.component('my-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean,
    // this allows using the `value` prop for a different purpose
    value: String
  },
  // ...
})
&ltmy-checkbox v-model="foo" value="some value"&gt&lt/my-checkbox&gt
</div>
上述代码等价于：
<div style="background:#D3D3D3;">
&ltmy-checkbox
  :checked="foo"
  @change="val =&gt { foo = val }"
  value="some value"&gt
&lt/my-checkbo&gt
</div>
    </pre>
  <div style="border:1px solid #999;" id="v1mtext">
    <p>多行文本</p>
    <span>Multiline message is:</span>
    <p style="white-space: pre-line">{{ message }}</p>
    <br>
    <textarea v-model="message" placeholder="add multiple lines"></textarea>
  </div>
  <p>官网上check box 等控件：</p><a href="https://cn.vuejs.org/v2/guide/forms.html" target="blank">https://cn.vuejs.org/v2/guide/forms.html<a></br>
  <!--第一章end-->
 </br>
  </br>
  </br>

  <!--第二章 -->
  <a style="color:blue;font-size:30px;" name="chapter2">2 vue组件（重复的东西就该用组件）</a>

  <p style="color:red;font-size:15px;">1 vue 组件基础</p>
  <p>全剧组件的声明：Vue.components('my-comp',{})</p>
  <p>在v2.js创建父实例（new Vue（）），下面的<a style="color:#590">绿框</a>是父实例对应的div</p>
  <p> 注意：一定要在父实例实例化 <strong style="color:coral">之前</strong>完成对组件的注册！！否则报错</p>

  <div style="border:1px solid #590;" id="father1">
    <my-component></my-component>
  </div>

  <p>局部组件声明,将component放在Vue实例中</p>
  <div style="border:1px solid #FFA500;" id="father2">
    <jubu-comp></jubu-comp>
  </div>

  <p style="color:#FFA500">dom一些限制请查看官网。</p>
  <p>vue.components的data选项若用在组件当中,则其必须是<strong style="color:coral">函数</strong>！！ </p>


  <div id="v2-compdata" style="border:1px solid #999;">
    <p>一起变化</p>
    <simple-counter></simple-counter>
    <simple-counter></simple-counter>
    <simple-counter></simple-counter>
    </br>
    <p>单独变化</p>
    <simple-counter2></simple-counter2>
    <simple-counter2></simple-counter2>
    <simple-counter2></simple-counter2>
  </div>
  </br>
  </br>
  </br>

  <p>子父组件 &ltparentc1 v-for="n in 3" key={{n}} &gt&lt/parentc1&gt</p>
  <p>加上key属性谷歌浏览器不会警告了</p>
  <div style="border:1px solid #999;" id="parentandchild">
    <p>汇总机器：总计:{{sum}}</p>
    <parentc1 v-for="n in 3" v-bind:parentid=n key={{n}} v-on:sumreport="sumtotal"></parentc1>


  </div>
  <img src="http://o9h3qt176.qnssl.com/n5d/cover_74463bd794074edc86fe9fb65fff65f9.png" height="300" width="400"></img>
  </br>
  </br>
  <p style="color:red;font-size:15px;">2 vue prop（子组件接受父组件的值）</p>
  <p>props选线代表组件需要的数据，这个选项可用于子组件使用父组件的数据。它可以理解成自定义组件的自定义属性</p>
  <p><strong>注意：</strong>如果犯贱地使用camelCased (驼峰式) 命名的 prop ，当使用的不是字符串模版， 需要转换为相对应的 kebab-case (短横线隔开式) 命名 （详细见官文：组件camelCase
    vs. kebab-case）</p>

  <p>动态prop</p>
  <div style="border:1px solid #999;" id="father3">
    <p>父组件 v-model使得input的value和data.parentMsg双向绑定</p>
    <input v-model="parentMsg">
    <br>
    <p>子组件，v-bind将props自定义属性mymessage绑定到parentMsg</p>
    <v2child1 v-bind:mymessage="parentMsg"></v2child1>
    </br>
    <p>下面的没使用v-bind，不是动态绑定，是字面量绑定，传入的不是parentMsg的值，只是个字符串。</p>
    <v2child1 mymessage="parentMsg"></v2child1>

    <p>prop是单向的，更多用法请仔细阅读官文：单向数据流</p>
    <a href="https://cn.vuejs.org/v2/guide/components.html" target="blank">https://cn.vuejs.org/v2/guide/components.html</a></p>
  </div>
  </br>
  <p>props里面的属性数据类型验证（定义属性的格式，甚至输入规则）。不符合规则使用空间会报错。 注意 props 会在组件实例创建之前进行校验，所以在 default 或 validator 函数里，诸如 data、computed 或 methods
    等实例属性还无法使用。
  </p>
  <div style="border:1px solid #999;" id="father4">
    <yanzheng v-bind:prop-c="string" v-bind:prop-f="int"> </yanzheng>
  </div>

  </br>
  <p>所谓非 prop 属性，就是它可以直接传入组件，而不需要定义相应的 prop。即需要什么属性，直接在组件的html上面用字面量绑定即可</p>

  <p style="color:red;font-size:15px;">3 vue 自定义事件（子组件发送值到父组件）</p>
  <pre>
  每个 Vue 实例都实现了<strong>事件接口 (Events interface)</strong>，即：
    使用 $on(eventName) 监听事件
    使用 $emit(eventName) 触发事件
    Vue 的事件系统分离自浏览器的 EventTarget API。尽管它们的运行类似，但是 $on 和 $emit 不是addEventListener 和 dispatchEvent 的别名。
    给组件绑定原生事件：可以使用 .native 修饰 v-on。例如：
    &ltmy-component v-on:click.native="doTheThing"&gt&lt/my-component&gt
</pre>
  <div style="border:1px solid #999;" id="counter-event-example">

    <p>父组件{{ total }}</p>
    <button-counter v-on:report="incrementTotal"></button-counter>
    <!--监听到report时间时，调用父组件的方法-->
    <button-counter v-on:report="incrementTotal"></button-counter>
  </div>

  <p> 有时候两个组件也需要通信 (非父子关系)。在简单的场景下，可以使用一个空的 Vue 实例作为中央事件总线。在复杂的情况下，我们应该考虑使用专门的状态管理模式.（见官文）</p>

  <p style="color:red;font-size:15px;">3 vue 内容分发(transclution)和slot</p>
  <p>仔细阅读官文。编辑作用域。slot插口 slot 标签是干什么的 具名slot</p>


  <div style="border:1px solid #FFA500;">
    <p>理解slot内容分发的意义</p>
    <pre>
    slot有什么用呢？比方下面的，slot中填入的，可能是不同样式的文字，可能是表格、图片，甚至是按钮,
和 implements一样，子组件只是定义一个interface{},父组件具体的实现它。
下面是个具名slot.
  </pre>
    <div style="border:1px solid #999;" id="stdiv1">
      <stfather1></stfather1>
    </div>
    <div style="border:1px solid #999;" id="stdiv2">
      <stfather1></stfather1>
    </div>
  </div>

  <p>作用域插槽和template的scope属性,作用，比内容分发更牛的是可以将data绑到模板</p>
  <div style="border:1px solid #999;" id="divsc1">
    <p>第一种实现</p>
    <scfather1 :itemsparent=itemsdata></scfather1>
    <p>第二种实现</p>
    <scfather2 :itemsparent=itemsdata>
      </scfather1>
  </div>

  <!--第二章end -->

  <!--第三章 -->
  <a style="color:blue;font-size:30px;" name="chapter3">3 vue自定义指令</a>

  <p style="color:red;font-size:15px;">1 vue 自定义指令Vue.directive</p>

  <div style="border:1px solid #999;" id="custom-order">
    <p>页面载入时，input 元素自动填入value：</p>
    全局<input v-focus> 局部
    <input v-focus2>
  </div>

  <p style="color:red;font-size:15px;">2 vue 自定义指令钩子</p>

  <pre>
    Vue.directive指令定义函数提供了几个钩子函数（可选）：
    bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。
    inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。
    update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）。
    componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。
    unbind: 只调用一次， 指令与元素解绑时调用

    钩子函数的参数有：
      el: 指令所绑定的元素，可以用来直接操作 DOM 。
      binding: 一个对象，包含以下属性：
        name: 指令名，不包括 v- 前缀。
        value: 指令的绑定值， 例如： v-my-directive="1 + 1", value 的值是 2。
        ldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。
        expression: 绑定值的字符串形式。 例如 v-my-directive="1 + 1" ， expression 的值是 "1 + 1"。
        arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 "foo"。
        modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。
        vnode: Vue 编译生成的虚拟节点，查阅 VNode API 了解更多详情。
        oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。
</pre>
  <div style="border:1px solid #999;" id="gouzi" v-gouzi:hello.a.b="message">
  </div>

  <!--第三章end -->
 </br>
  </br>
   <!--第四章-->
  <a style="color:blue;font-size:30px;" name="chapter4">4 vue路由 实现单页多试图</a>
  </br>
  <a href="http://www.runoob.com/vue2/vue-routing.html " target="blank">安装</a>
  <a href="https://router.vuejs.org/zh-cn/" target="blank">文档</a>
   <!--第四章end -->
  
  </br>
  </br>
  </br>
  </br>
  </br>

  <script src="v0.js"></script>
  <script src="v1.js"></script>
  <script src="v2.js"></script>
  <script src="v3.js"></script>

  <scripr src="jQueryVue.js">
    </script>



</body>