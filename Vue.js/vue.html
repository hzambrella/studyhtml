<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>hz初学Vue.js</title>
  <script src=vue.js></script>
  <script src="http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js">
  </script>

  <style type="text/css">
    #panel,
    #flip {
      padding: 5px;
      text-align: center;
      background-color: #e5eecc;
      border: solid 1px #c3c3c3;
    }

    #panel {
      padding: 50px;
      display: none;
    }
  </style>


</head>

<body>
  <!--锚-->

  <div id="mao">
    <a v-for="(item,index) in brlist" v-bind:href="char+index">{{char}}{{index}}:{{item.title}}</a>
    </br>
  </div>
  <!--
  <div id="mao2">
    <maos v-for="item in brlist" v-bind:mao="item" v-bind:char="char"  ></maos>
  </div>
  -->
  <!--锚 end -->


  <div id="pre2">
    <pre2 v-for="item in pre2list" v-bind:mao="item"></pre2>
  </div>
  <p>v-bind:实现属性和数据的绑定</p>
  <p>v-bind：可以缩写成 ：</p>
  <p>下面的title属性被绑定成数据message=hello vue</p>
  <p id="haha" v-bind:title="message">nihao</p>


  <!--第一章-->

  <a style="color:blue;font-size:30px;" name="chapter1">1 vue基础</a>
  <p style="color:red;font-size:15px;">1 vue实例</p>
  <p> new Vue()，这叫<strong style="color:coral">构造器</strong></p>


  <div style="border:1px solid #999;">
    <p id="p1" v-bind:title="a">nihao2</p>
    <p>这些被代理的属性是响应的，也就是说值的任何改变都是触发视图的重新渲染。</p>
    <button id="btn11" onclick="changenihao2()">change nihao2</button>
    </br>
  </div>

  <!--答案-->
  <p>$的作用，抽出属性</p>
  <div id="ans11" style="border:1px solid #999;">
    <p v-for="item in ans11list" v-if="seen">{{item}}
      <p>
  </div>
  </br>
  <input id="btn111" type="button" value="隐藏" onclick="hideans()">
  </br>


  <pre>
  每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如，实例需要配置数据观测(data observer)、编译模版、挂载实
  例到 DOM ，然后在数据变化时更新 DOM 。在这个过程中，实例也会调用一些 生命周期钩子 ，这就给我们提供了执行自定义逻辑的机会。
  例如，created 这个钩子在实例被创建之后被调用.
  
 <!-- <img src="https://cn.vuejs.org/images/lifecycle.png"  ></img>-->
 <a href="https://cn.vuejs.org/images/lifecycle.png" target="blank" >生命周期 <a>
    </pre>


  <p style="color:red;font-size:15px;">2 vue模板</p>
  <pre>
通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上所有的数据绑定
  </pre>

  <div style="border:1px solid #999;">
    <p id="p121" v-once v-bind:title="a">nihao v-once,数据：{{a}}</p>
    <button id="btn12" onclick="changenihaovonce()">change nihao v-once</button>
    </br>
  </div>

  <div style="border:1px solid #999;">
    <p id="p122" v-if="seen"> Vue.js 提供了完全的 JavaScript 表达式支持。{{ ok ? 'YES' : 'NO' }} </p>

    <input id="btn13" type="button" value="模板支持js表达式 NO" onclick="changeok()">
    <input id="btn14" type="button" value="v-if的用法： 隐藏" onclick="changevif()">
  </div>

  <p style="color:green;">过滤器TODO</p>

  <p style="color:red;font-size:15px;">3 vue计算属性computed (注意官方文档对其与methods,watch区别的说明)</p>
  <div style="border:1px solid #999;">
    <div id="comp1">
      <p>Original message: "{{ message }}"</p>
      <p>Computed reversed message: "{{ reversedMessage }}"</p>
    </div>
  </div>

  <a href="https://cn.vuejs.org/v2/guide/computed.html" target="blank">官文watch method的对比</a>
  <pre>
  与官文methods不同的是,计算属性是基于message和reversedMessage的依赖进行缓存的
  只要 message 还没有发生改变，多次访问 reversedMessage 计算属性computed会立即返回之前的计算结果，而不必再次执行函数。
  相比而言，只要发生重新渲染，method 调用总会执行该函数。
  官文上，与的watch相比，compute 有事更简洁
  </pre>

  <p>computed 的getter和setter</p>
  <p>firstname lastname 和fullName产生了联系</p>

  <div style="border:1px solid #999;">
    <div id="v1name">
      <p><b style="color:aqua">fullName:</b>{{fullName}} </p>
      <p><b style="color:aqua">firstname:</b>{{firstName}} </p>
      <p><b style="color:aqua">lastName:</b> {{lastName}}</p>

      firstname <input id="v1firstname" name="firstname"></br>
      lastname <input id="v1lastname" name="lastname"></br>

      <button v-on:click="v1setname">submit</button>

    </div>
    <pre>
      Vue 提供一个更通用的方法通过 watch 选项，来响应数据的变化。当你想要在数据变化响应时，执行异步操作或开销较大的操作，这是很有用的。例子见官网yesno。
    </pre>
  </div>


  <p style="color:red;font-size:15px;">4 vue class style 略</p>
  <p style="color:red;font-size:15px;">5 vue 条件渲染v-if v-show</p>

  <a href="http://www.cnblogs.com/wmhuang/p/5420344.html" target="blank">v-if 和v-show的区别</a>
  <pre>
手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；
使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换。
用template可以v-if整个组
2.1版本新增了 v-else-if可满足条件控制的需求
</pre>

  <div style="border:1px solid #999;" id="v1login">
    <p>{{indexlogin}}{{logintype}}</p>

    <template v-if="logintype=='user'">
      <label>用户名登陆</label>
      <input placeholder="Enter you name">
    </template>

    <template v-if="logintype=='QQemail'">
      <label>QQ邮箱登陆</label>
      <input placeholder="Enter your QQemail">
    </template>

    <template v-if="logintype=='sinaemail'">
      <label>sina邮箱登陆</label>
      <input placeholder="Enter your sinaemail">
    </template>
    </br>

    <p style="color:coral">试验时写错的地方 1.&lt/template&gt &lt/template&gt 2.logintype='sinaemail' </p>


    <button v-on:click="changelogintype">toggle login type</button>

    <p>那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模版使用了相同的元素，&ltinput&gt 不会被替换掉——仅仅是替换了它的 placeholder。</p>
    <p>这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来声明“这两个元素是完全独立的——不要复用它们”。只需添加一个具有唯一值的 key 属性即可：</p>
    <p> &ltinput placeholder="Enter you phone" <a style="color:red">key="phone"&gt</a></p>

    <p>联系方式</p>
    <template v-if="connect=='phone'">
      <label>电话号码</label>
      <input placeholder="Enter you phone" key="phone">
    </template>

    <template v-if="connect=='email'">
      <label>邮箱</label>
      <input placeholder="Enter you email" key="email">
    </template>
    <button v-on:click="changeconnect">toggle connect type</button>
  </div>


  <p style="color:red;font-size:15px;">6 vue 列表渲染v-for</p>
  <p>看标题锚的例子：</p>
  <p>(item,index) in brlist的index是个索引</p>
  <div style="border:1px solid #999;" id="v1login">
    <p>&lta&gtv-for="(item,index) in brlist" v-bind:href="char+index">{{char}}{{index}}:{{item.title}}&lt/a&gt</p>
  </div>

  <p>如同 v-if 模板，你也可以用带有 v-for 的 &lttemplate&gt 标签来渲染多个元素块。</p>
  <p>整数迭代：&ltspan&gt v-for="n in 10">{{ n }} &lt/span&gt(失败了。。。)</p>
  <div>
    <p v-for="n in 10">{{ n }} </p>
  </div>

  <p>你也可以用 v-for 通过一个对象的属性来迭代。</p>

  <p style="color:red;font-size:15px;">7 vue 事件v-on（可缩写v-on:click ---> @click）</p>

  <p>v-on基础，见上面按钮的实现</p>
  <p>内联处理器 </p>
  <p>有时也需要在内联语句处理器中访问原生 DOM 事件。可以用特殊变量 $event 把它传入方法：</p>
  <div style="border:1px solid #999;" id="v1neilian">
    <p>&ltbutton v-on:click="say('hi')"&gtSay hi&lt/button&gt </p>
    <p>&ltbutton v-on:click="warn('Form cannot be submitted yet.', $event)"&gtSubmit&lt/button&gt</p>
    <button v-on:click="say('hi')">Say hi</button>
    <button v-on:click="warn('Form cannot be submitted yet.', $event)">Submit</button>
  </div>
  <a href="https://cn.vuejs.org/v2/guide/events.html" target="blank">事件修饰符,键盘鼠标事件修饰符,官网,重要</a></br>

  <p style="color:red;font-size:15px;">8 vue 表单渲染v-model</p>
  <pre>
  你可以用 v-model 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。
  尽管有些神奇，但 v-model 本质上不过是语法糖，它负责监听用户的输入事件以更新数据，并特别处理一些极端的例子。
    </pre>
  <div style="border:1px solid #999;" id="v1mtext">
    <p>多行文本</p>
    <span>Multiline message is:</span>
    <p style="white-space: pre-line">{{ message }}</p>
    <br>
    <textarea v-model="message" placeholder="add multiple lines"></textarea>
  </div>
  <p>官网上check box 等控件：</p><a href="https://cn.vuejs.org/v2/guide/forms.html" target="blank">https://cn.vuejs.org/v2/guide/forms.html<a></br>
  <!--第一章end-->
 </br>
  </br>
  </br>

  <!--第二章 -->
  <a style="color:blue;font-size:30px;" name="chapter1">2 vue组件（重复的东西就该用组件）</a>

  <p style="color:red;font-size:15px;">1 vue 组件基础</p>
  <p>全剧组件的声明：Vue.components('my-comp',{})</p>
  <p>在v2.js创建父实例（new Vue（）），下面的<a style="color:#590">绿框</a>是父实例对应的div</p>
  <p> 注意：一定要在父实例实例化 <strong style="color:coral">之前</strong>完成对组件的注册！！否则报错</p>

  <div style="border:1px solid #590;" id="father1">
    <my-component></my-component>
  </div>

  <p>局部组件声明,将component放在Vue实例中</p>
  <div style="border:1px solid #FFA500;" id="father2">
    <jubu-comp></jubu-comp>
  </div>

  <p style="color:#FFA500">dom一些限制请查看官网。</p>
  <p>vue.components的data选项若用在组件当中,则其必须是<strong style="color:coral">函数</strong>！！ </p>


  <div id="v2-compdata">
    <p>一起变化</p>
    <simple-counter></simple-counter>
    <simple-counter></simple-counter>
    <simple-counter></simple-counter>
    </br>
    <p>单独变化</p>
    <simple-counter2></simple-counter2>
    <simple-counter2></simple-counter2>
    <simple-counter2></simple-counter2>
  </div>
  </br>
  </br>
  <p style="color:red;font-size:15px;">2 vue prop（子组件接受父组件的值）</p>
  <p>props选线代表组件需要的数据，这个选项可用于子组件使用父组件的数据。它可以理解成自定义组件的自定义属性</p>
  <p><strong>注意：</strong>如果犯贱地使用camelCased (驼峰式) 命名的 prop ，当使用的不是字符串模版， 需要转换为相对应的 kebab-case (短横线隔开式) 命名 （详细见官文：组件camelCase
    vs. kebab-case）</p>

  <p>动态prop</p>
  <div style="border:1px solid #999;" id="father3">
    <p>父组件 v-model使得input的value和data.parentMsg双向绑定</p>
    <input v-model="parentMsg">
    <br>
    <p>子组件，v-bind将props自定义属性mymessage绑定到parentMsg</p>
    <v2child1 v-bind:mymessage="parentMsg"></v2child1>
    </br>
    <p>下面的没使用v-bind，不是动态绑定，是字面量绑定，传入的不是parentMsg的值，只是个字符串。</p>
    <v2child1 mymessage="parentMsg"></v2child1>

    <p>prop是单向的，更多用法请仔细阅读官文：单向数据流</p>
    <a href="https://cn.vuejs.org/v2/guide/components.html" target="blank">https://cn.vuejs.org/v2/guide/components.html</a></p>
  </div>
  </br>
  <p>props里面的属性数据类型验证（定义属性的格式，甚至输入规则）。不符合规则使用空间会报错。 注意 props 会在组件实例创建之前进行校验，所以在 default 或 validator 函数里，诸如 data、computed 或 methods
    等实例属性还无法使用。
  </p>
  <div style="border:1px solid #999;" id="father4">
    <yanzheng v-bind:prop-c="string" v-bind:prop-f="int"> </yanzheng>
  </div>

  </br>
  <p>所谓非 prop 属性，就是它可以直接传入组件，而不需要定义相应的 prop。即需要什么属性，直接在组件的html上面用字面量绑定即可</p>

  <p style="color:red;font-size:15px;">3 vue 自定义事件（子组件发送值到父组件）</p>
  <pre>
  每个 Vue 实例都实现了<strong>事件接口 (Events interface)</strong>，即：
    使用 $on(eventName) 监听事件
    使用 $emit(eventName) 触发事件
    Vue 的事件系统分离自浏览器的 EventTarget API。尽管它们的运行类似，但是 $on 和 $emit 不是addEventListener 和 dispatchEvent 的别名。
    给组件绑定原生事件：可以使用 .native 修饰 v-on。例如：
    &ltmy-component v-on:click.native="doTheThing"&gt&lt/my-component&gt
</pre>
  <div style="border:1px solid #999;" id="counter-event-example">

    <p>父组件{{ total }}</p>
    <button-counter v-on:report="incrementTotal"></button-counter>
    <!--监听到report时间时，调用父组件的方法-->
    <button-counter v-on:report="incrementTotal"></button-counter>
  </div>
  <!--第二章end -->
  </br>
  </br>
  </br>
  </br>
  </br>

  <script src="v0.js"></script>
  <script src="v1.js"></script>
  <script src="v2.js"></script>

  <scripr src="jQueryVue.js">
    </script>



</body>